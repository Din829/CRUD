(自我记录，暂时不需要管和参考这个文件，汇总结束后再考虑优化)
1.输出内容（日志）过于多（特别是无意义的），更简洁一点
2.---节点: 格式化 Schema---时间略长（可增加可视化？？）

3.条件令牌分配(应该已解决)
检查用户名"bob"的用户是否拥有"openai"的API令牌。
如果没有，为其添加一个"openai"的API令牌，令牌值为"tok_bob_2"，创建时间为2025年5月3日14:00:00。
然后，为"bob"创建一个标题为"API集成"的提示，类别为"coding"，内容为"编写一个连接外部API的脚本"，时间戳与令牌相同。
（此问题复合了查询与新增，暂时无法处理）
（此问题包含了验证，暂时无法处理）

4.复合要求(应该已解决)
对于所有拥有"huggingface"API令牌的用户，将其令牌提供者更改为"openai"，并将令牌值更新为"tok_migrated_[username]"。将这些令牌的updated_at时间戳设为2025年5月3日11:00:00。
同时，为每个受影响的用户创建一个标题为"迁移通知"的提示，类别为"writing"，内容为"撰写系统升级通知"，时间戳相同。
（现阶段还不能进行修改新增同时实现）

5.当前时间
目前ai输出的当前时间大概是美国时间？最好改为日本


6.记录所有修改记录


7.利用多表联合，未来可考虑输出为图表或者Excel


8.复杂指令，即使非复合需求也常常被认为是复合


9.添加复合流程的删除操作(应该已解决)


10.出现唯一键重复添加应需做到前端提醒而非500


11.修改表结构？（太难）

12.是否可以外层再套一个AI智能体？(制作成MCP)


13.可以实现创建新表等功能

# --- 新增待优化点 (来自复合流程随机占位符讨论) ---
14. **通用化随机占位符处理机制**:
    - **问题现状**: 当前 `_process_value` 在处理 `{{random(type)}}` 时，对于不支持的 `type` (如 `japanese_name_4_chars`) 会导致占位符处理失败或返回原始占位符，进而引发后端错误（如唯一键冲突）。
    - **当前临时解决**: (如果后续实施) 可能会为特定的 `japanese_name_4_chars` 添加一个硬编码的或非常简单的占位生成逻辑以通过当前测试。
    - **长远目标**: 设计一个更灵活的随机内容生成机制，例如：
        - 随机生成器注册表：允许动态注册不同类型的随机内容生成函数 (如生成指定长度和语言的姓名、地址、邮箱、特定格式的字符串等)。
        - `{{random(spec)}}` 中的 `spec` 可以支持更丰富的定义，如 `{{random(name, lang=jp, length=4)}}` 或 `{{random(string, length=10, charset=alphanum)}}`。
        - `_process_value` 能够解析 `spec`，查找对应的生成器并传递参数。
    - **优点**: 提高系统的灵活性和可扩展性，方便未来支持更多种类的随机数据生成需求，而无需频繁修改核心的占位符处理代码。
    问题现状补充：即使占位符被解析，如果同一个随机占位符（如 {{random(type)}}）在原始计划中被用于多个需要保证唯一性的字段（例如，在一次批量更新中为多个用户的 username 字段都使用 {{random(name)}}），当前的占位符处理逻辑（对原始计划中的占位符进行一次性替换）会导致所有这些字段都被赋上相同的随机值，从而引发唯一键冲突。
长远目标应考虑：确保在批量操作中，即使源计划中使用了相同的随机占位符模式，最终应用到不同记录的唯一字段上的值也应该是独立生成的、唯一的随机值。这可能需要在后端 /execute_batch_operations 处理这类特定随机占位符时，对每个受影响的行独立生成随机值，或者LangGraph端在生成最终计划时就确保这一点。

15. **处理操作与查询/分析的复合意图**：
    - **问题现状**: 当用户输入包含数据操作（如修改）和数据查询/分析（如统计）的混合指令时，系统可能只执行了其中一个能识别的流程（如分析），而忽略了另一部分。
    - **期望行为**: 理想情况下，系统应能识别这是一个它当前无法完整处理的复合请求，并给予用户明确反馈。
    - **优化方向**:
        - **方案1 (反馈与引导)**: 识别混合意图后，明确告知用户当前无法同时处理这两类操作，并引导用户拆分请求或选择优先执行部分。
        - **方案2 (部分执行与提示)**: 如果系统能执行其中一部分（如分析），则执行该部分，然后提示用户另一部分（如修改）需要单独请求。
        - **方案3 (未来-任务分解)**: 更高级的智能体可以尝试将混合指令分解为可独立执行的子任务，并按顺序处理或询问用户。

16. **优化不明确查询的范围**：
    - **问题现状**: 对于如"列出用户的令牌"这类略不明确的查询，系统当前倾向于返回所有相关记录。
    - **优化方向**: 
        - **增强上下文理解**: 未来的智能体或更复杂的对话管理可以利用上下文推断用户可能想要的范围。
        - **适度澄清**: 考虑在某些模式下（如查询目标实体未在近期对话中明确指定时）主动进行澄清，询问用户是否需要所有记录还是特定子集，但这需平衡信息获取效率与用户交互成本。

17. **优化 `save_content` 状态的清理机制**（测试环节）：
    - **问题现状**: 当前 `reset_after_operation_action` 为确保 `format_operation_response_action` 能获取操作类型，没有重置 `save_content` 状态。这可能导致该状态在操作完成后仍然存在，直到下一个完全独立的用户请求开始时才可能被 `route_initialization_node` 清理（如果 `route_initialization_node` 设计了对其的清理）。
    - **潜在风险**: 如果 `save_content` 未被及时清理，在某些罕见的流程异常或不完整执行的情况下，可能会干扰后续不相关的操作。
    - **优化方向**:
        - **方案A (增强入口清理)**: 确保图的全局入口节点 (`route_initialization_node`) 在开始处理任何新的用户查询前，可靠地重置包括 `save_content` 在内的所有上一轮可能残留的流程控制状态。
        - **方案B (传递操作类型)**: 修改 `execute_operation_action`，使其在成功执行操作后，将当前操作类型（来自当时的 `save_content`）保存到一个新的临时状态字段 (例如 `last_executed_operation_type`)。然后，`reset_after_operation_action` 可以安全地重置 `save_content`。`format_operation_response_action` 则从 `last_executed_operation_type` 读取操作类型。这个 `last_executed_operation_type` 和 `api_call_result` 应该在格式化响应完成后或在图的下一个通用清理点被清除。
        - **目标**: 确保流程控制状态（如 `save_content`）的生命周期被精确管理，只在当前操作的确认和执行阶段有效，操作完成后即被清理，避免跨操作轮次的意外干扰。


18.复合操作事务处理？
例如
1. 删除 `prompts` 表中属于用户“吴刚”，且 ID 为 1 的提示词记录。
2. 更新 `api_tokens` 表中属于用户“Chris”，且 ID 为 11 的记录，将 token_value 修改为 lisi-token-updated-via-composite，并更新修改时间。
1的ID不是1，是不正确的，无法删除，直接掠过了（如果不说ID是可以正常删除的）。2正常删除了。复合流程也没有明确提示
但如果出现500等报错还是会触发正常事务处理的


19.修改流程的用户反馈不友好，还是json格式




20.复合流程（包括所有流程）的错误反馈都一般，涉及到flask的错误可以尝试让AI分析flask错误反馈给用户（这个等制作前端时再解决也ok）
